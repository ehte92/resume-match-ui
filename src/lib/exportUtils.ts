import type { AnalysisResponse } from '@/types/api';
import { getScoreInterpretation } from './scoreUtils';

/**
 * Format analysis data as Markdown
 */
export function formatAsMarkdown(analysis: AnalysisResponse): string {
  const matchScore = Number(analysis.match_score) || 0;
  const atsScore = Number(analysis.ats_score) || 0;
  const semanticScore = Number(analysis.semantic_similarity) || 0;

  const date = new Date(analysis.created_at).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });

  let markdown = '# Resume Analysis Report\n\n';

  // Header info
  if (analysis.job_title) {
    markdown += `**Position:** ${analysis.job_title}\n`;
  }
  if (analysis.company_name) {
    markdown += `**Company:** ${analysis.company_name}\n`;
  }
  markdown += `**Date:** ${date}\n\n`;

  markdown += '---\n\n';

  // Scores Section
  markdown += '## 📊 Analysis Scores\n\n';
  markdown += `### Match Score: ${matchScore.toFixed(0)}%\n`;
  markdown += `${getScoreInterpretation(matchScore, 'match')}\n\n`;

  markdown += `### ATS Score: ${atsScore.toFixed(0)}%\n`;
  markdown += `${getScoreInterpretation(atsScore, 'ats')}\n\n`;

  markdown += `### Semantic Similarity: ${semanticScore.toFixed(0)}%\n`;
  markdown += `${getScoreInterpretation(semanticScore, 'semantic')}\n\n`;

  markdown += '---\n\n';

  // Keywords Analysis
  markdown += '## 🔑 Keywords Analysis\n\n';
  const totalKeywords = (analysis.matching_keywords?.length || 0) + (analysis.missing_keywords?.length || 0);
  const matchPercentage = totalKeywords > 0
    ? ((analysis.matching_keywords?.length || 0) / totalKeywords * 100).toFixed(0)
    : 0;
  markdown += `**Match Rate:** ${matchPercentage}% (${analysis.matching_keywords?.length || 0} of ${totalKeywords} keywords)\n\n`;

  if (analysis.matching_keywords && analysis.matching_keywords.length > 0) {
    markdown += '### ✅ Matched Keywords\n';
    analysis.matching_keywords.forEach((keyword) => {
      markdown += `- ${keyword}\n`;
    });
    markdown += '\n';
  }

  if (analysis.missing_keywords && analysis.missing_keywords.length > 0) {
    markdown += '### ❌ Missing Keywords\n';
    analysis.missing_keywords.forEach((keyword) => {
      markdown += `- ${keyword}\n`;
    });
    markdown += '\n';
  }

  markdown += '---\n\n';

  // ATS Issues
  if (analysis.ats_issues && analysis.ats_issues.length > 0) {
    markdown += '## ⚠️ ATS Issues\n\n';
    analysis.ats_issues.forEach((issue, index) => {
      markdown += `### ${index + 1}. ${issue.type}\n`;
      markdown += `**Severity:** ${issue.severity}\n`;
      if (issue.section) {
        markdown += `**Section:** ${issue.section}\n`;
      }
      markdown += `**Issue:** ${issue.message}\n`;
      markdown += `**Recommendation:** ${issue.recommendation}\n\n`;
    });
    markdown += '---\n\n';
  }

  // AI Suggestions
  if (analysis.ai_suggestions && analysis.ai_suggestions.length > 0) {
    markdown += '## 💡 AI Suggestions\n\n';
    analysis.ai_suggestions.forEach((suggestion, index) => {
      markdown += `### ${index + 1}. ${suggestion.type}\n`;
      markdown += `**Priority:** ${suggestion.priority}\n`;
      if (suggestion.category) {
        markdown += `**Category:** ${suggestion.category}\n`;
      }
      markdown += `**Issue:** ${suggestion.issue}\n`;
      markdown += `**Suggestion:** ${suggestion.suggestion}\n`;
      if (suggestion.example) {
        markdown += `**Example:** ${suggestion.example}\n`;
      }
      if (suggestion.impact) {
        markdown += `**Impact:** ${suggestion.impact}\n`;
      }
      markdown += '\n';
    });
    markdown += '---\n\n';
  }

  // Rewritten Bullets
  if (analysis.rewritten_bullets && analysis.rewritten_bullets.length > 0) {
    markdown += '## ✨ AI-Improved Bullet Points\n\n';
    analysis.rewritten_bullets.forEach((bullet, index) => {
      markdown += `### ${index + 1}.\n`;
      markdown += `**Original:**\n> ${bullet.original}\n\n`;
      markdown += `**Improved:**\n> ${bullet.improved}\n\n`;
      if (bullet.reason) {
        markdown += `**Why:** ${bullet.reason}\n\n`;
      }
    });
  }

  // Footer
  markdown += '---\n\n';
  markdown += '*Generated by Resume Match AI*\n';

  return markdown;
}

/**
 * Format analysis data as plain text
 */
export function formatAsText(analysis: AnalysisResponse): string {
  const matchScore = Number(analysis.match_score) || 0;
  const atsScore = Number(analysis.ats_score) || 0;
  const semanticScore = Number(analysis.semantic_similarity) || 0;

  const date = new Date(analysis.created_at).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });

  let text = '============================================\n';
  text += '       RESUME ANALYSIS REPORT\n';
  text += '============================================\n\n';

  // Header info
  if (analysis.job_title) {
    text += `Position: ${analysis.job_title}\n`;
  }
  if (analysis.company_name) {
    text += `Company: ${analysis.company_name}\n`;
  }
  text += `Date: ${date}\n\n`;

  text += '============================================\n\n';

  // Scores Section
  text += 'ANALYSIS SCORES\n';
  text += '--------------------------------------------\n\n';
  text += `Match Score: ${matchScore.toFixed(0)}%\n`;
  text += `${getScoreInterpretation(matchScore, 'match')}\n\n`;

  text += `ATS Score: ${atsScore.toFixed(0)}%\n`;
  text += `${getScoreInterpretation(atsScore, 'ats')}\n\n`;

  text += `Semantic Similarity: ${semanticScore.toFixed(0)}%\n`;
  text += `${getScoreInterpretation(semanticScore, 'semantic')}\n\n`;

  text += '============================================\n\n';

  // Keywords Analysis
  text += 'KEYWORDS ANALYSIS\n';
  text += '--------------------------------------------\n\n';
  const totalKeywords = (analysis.matching_keywords?.length || 0) + (analysis.missing_keywords?.length || 0);
  const matchPercentage = totalKeywords > 0
    ? ((analysis.matching_keywords?.length || 0) / totalKeywords * 100).toFixed(0)
    : 0;
  text += `Match Rate: ${matchPercentage}% (${analysis.matching_keywords?.length || 0} of ${totalKeywords} keywords)\n\n`;

  if (analysis.matching_keywords && analysis.matching_keywords.length > 0) {
    text += 'Matched Keywords:\n';
    analysis.matching_keywords.forEach((keyword) => {
      text += `  • ${keyword}\n`;
    });
    text += '\n';
  }

  if (analysis.missing_keywords && analysis.missing_keywords.length > 0) {
    text += 'Missing Keywords:\n';
    analysis.missing_keywords.forEach((keyword) => {
      text += `  • ${keyword}\n`;
    });
    text += '\n';
  }

  text += '============================================\n\n';

  // ATS Issues
  if (analysis.ats_issues && analysis.ats_issues.length > 0) {
    text += 'ATS ISSUES\n';
    text += '--------------------------------------------\n\n';
    analysis.ats_issues.forEach((issue, index) => {
      text += `${index + 1}. ${issue.type}\n`;
      text += `   Severity: ${issue.severity}\n`;
      if (issue.section) {
        text += `   Section: ${issue.section}\n`;
      }
      text += `   Issue: ${issue.message}\n`;
      text += `   Recommendation: ${issue.recommendation}\n\n`;
    });
    text += '============================================\n\n';
  }

  // AI Suggestions
  if (analysis.ai_suggestions && analysis.ai_suggestions.length > 0) {
    text += 'AI SUGGESTIONS\n';
    text += '--------------------------------------------\n\n';
    analysis.ai_suggestions.forEach((suggestion, index) => {
      text += `${index + 1}. ${suggestion.type}\n`;
      text += `   Priority: ${suggestion.priority}\n`;
      if (suggestion.category) {
        text += `   Category: ${suggestion.category}\n`;
      }
      text += `   Issue: ${suggestion.issue}\n`;
      text += `   Suggestion: ${suggestion.suggestion}\n`;
      if (suggestion.example) {
        text += `   Example: ${suggestion.example}\n`;
      }
      if (suggestion.impact) {
        text += `   Impact: ${suggestion.impact}\n`;
      }
      text += '\n';
    });
    text += '============================================\n\n';
  }

  // Rewritten Bullets
  if (analysis.rewritten_bullets && analysis.rewritten_bullets.length > 0) {
    text += 'AI-IMPROVED BULLET POINTS\n';
    text += '--------------------------------------------\n\n';
    analysis.rewritten_bullets.forEach((bullet, index) => {
      text += `${index + 1}.\n`;
      text += `   Original:\n   ${bullet.original}\n\n`;
      text += `   Improved:\n   ${bullet.improved}\n\n`;
      if (bullet.reason) {
        text += `   Why: ${bullet.reason}\n\n`;
      }
    });
  }

  // Footer
  text += '============================================\n';
  text += 'Generated by Resume Match AI\n';
  text += '============================================\n';

  return text;
}

/**
 * Format improved bullets only as text
 */
export function formatImprovedBulletsAsText(analysis: AnalysisResponse): string {
  if (!analysis.rewritten_bullets || analysis.rewritten_bullets.length === 0) {
    return 'No improved bullet points available.';
  }

  let text = 'AI-IMPROVED BULLET POINTS\n';
  text += '====================================\n\n';

  analysis.rewritten_bullets.forEach((bullet, index) => {
    text += `${index + 1}. ${bullet.improved}\n\n`;
  });

  return text;
}

/**
 * Download text content as a file
 */
export function downloadTextFile(content: string, filename: string, mimeType = 'text/plain') {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Generate a filename for export
 */
export function generateExportFilename(analysis: AnalysisResponse, extension: string): string {
  const date = new Date(analysis.created_at).toISOString().split('T')[0];
  const jobTitle = analysis.job_title?.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'analysis';
  const company = analysis.company_name?.replace(/[^a-z0-9]/gi, '_').toLowerCase();

  return company
    ? `resume_analysis_${jobTitle}_${company}_${date}.${extension}`
    : `resume_analysis_${jobTitle}_${date}.${extension}`;
}
